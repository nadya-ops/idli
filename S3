Q3.1#include <stdio.h> 
#include <sys/stat.h> 
int main(int argc, char *argv[]) 
{ 
struct stat st; 
if (argc != 2) { 
printf("Usage: %s <filename>\n", argv[0]); 
return 1; 
} 
if (stat(argv[1], &st) == -1) { 
perror("stat"); 
return 1; 
} 
printf("File: %s\n", argv[1]); 
printf("Inode Number: %ld\n", st.st_ino); 
if (S_ISREG(st.st_mode))      
printf("Type: Regular File\n"); 
else if (S_ISDIR(st.st_mode)) printf("Type: Directory\n"); 
else if (S_ISCHR(st.st_mode)) printf("Type: Character Device\n"); 
else if (S_ISBLK(st.st_mode)) printf("Type: Block Device\n"); 
else if (S_ISFIFO(st.st_mode))printf("Type: FIFO/PIPE\n"); 
else if (S_ISLNK(st.st_mode)) printf("Type: Symbolic Link\n"); 
else if (S_ISSOCK(st.st_mode))printf("Type: Socket\n"); 
return 0; 
} 
Q3.2#include <stdio.h> 
#include <unistd.h> 
#include <signal.h> 
#include <stdlib.h> 
#include <sys/wait.h> 
pid_t pid; 
void child_dead(int sig) { 
printf("Child terminated normally.\n"); 
} 
void alarm_handler(int sig) { 
printf("Timeout! Killing child...\n"); 
kill(pid, SIGKILL); 
} 
int main() 
{ 
signal(SIGCHLD, child_dead); 
signal(SIGALRM, alarm_handler); 
pid = fork(); 
if (pid == 0) { 
execlp("sleep", "sleep", "10", NULL); // child runs long command 
perror("exec"); 
exit(1); 
} 
else { 
alarm(5);       
wait(NULL);    
} 
return 0; 
}
